function M(e){return Array.from(new Set(e))}const ee="0.4.171",O={projectName:"Vike",projectVersion:ee},I=`_${O.projectName.toLowerCase()}`;function v(e,t){const n=te();return n[e]=n[e]||t}function te(){return globalThis[I]=globalThis[I]||{}}const d=v("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),ne="The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",J="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function D(){{const e=M(d.instances);ie(e.length<=1,`Both vike@${e[0]} and vike@${e[1]} loaded. Only one version should be loaded.`)}d.checkSingleInstance&&d.instances.length>1&&S(!1,J,{onlyOnce:!0,showStackTrace:!0})}function Pe(e){S(d.isClientRouting!==!1,ne,{onlyOnce:!0,showStackTrace:!0}),S(d.isClientRouting===void 0,J,{onlyOnce:!0,showStackTrace:!0}),d.isClientRouting=!0,e&&(d.checkSingleInstance=!0),D()}function re(){d.instances.push(O.projectVersion),D()}function ie(e,t){if(e)return;const n=`[vike][Wrong Usage] ${t}`;throw new Error(n)}function S(e,t,{onlyOnce:n,showStackTrace:r}){if(e)return;const i=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:s}=d,o=n===!0?i:n;if(s.has(o))return;s.add(o)}console.warn(r?new Error(i):i)}function se(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function U(e,t){const n=new Error(e);return se()&&(n.stack=oe(n.stack,t)),n}function oe(e,t){if(!e)return e;const n=ce(e);let r=0;return n.filter(s=>s.includes(" (internal/")||s.includes(" (node:internal")?!1:r<t&&ae(s)?(r++,!1):!0).join(`
`)}function ae(e){return e.startsWith("    at ")}function ce(e){return e.split(/\r?\n/)}function k(e){return typeof e=="object"&&e!==null}const u=new Proxy({},{get:(e,t)=>n=>t!=="code"?n:`\`${n}\``}),c=v("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){t==="info"?console.log(e):console.warn(e)},showStackTraceList:new WeakSet});re();const ue="[vike]",le=`[vike@${O.projectVersion}]`,_=2;function a(e,t){var s;if(e)return;const n=(()=>{if(!t)return null;const o=typeof t=="string"?t:JSON.stringify(t);return u.dim(`Debug info (for Vike maintainers; you can ignore this): ${o}`)})();let r=["You stumbled upon a Vike bug.",`Go to ${u.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");r=b(r),r=T(r,"Bug"),r=$(r,!0);const i=U(r,_);throw(s=c.onBeforeLog)==null||s.call(c),i}function y(e,t,{showStackTrace:n}={}){var i;if(e)return;t=b(t),t=T(t,"Wrong Usage"),t=$(t);const r=U(t,_);throw n&&c.showStackTraceList.add(r),(i=c.onBeforeLog)==null||i.call(c),r}function fe(e){return e=b(e),e=T(e,"Error"),e=$(e),U(e,_)}function A(e,t,{onlyOnce:n,showStackTrace:r}){var i;if(!e){if(t=b(t),t=T(t,"Warning"),t=$(t),n){const{alreadyLogged:s}=c,o=n===!0?t:n;if(s.has(o))return;s.add(o)}if((i=c.onBeforeLog)==null||i.call(c),r){const s=new Error(t);c.showStackTraceList.add(s),c.logger(s,"warn")}else c.logger(t,"warn")}}function he(e,t,{onlyOnce:n}){var r;if(!e){if(t=b(t),t=$(t),n){const{alreadyLogged:i}=c,s=t;if(i.has(s))return;i.add(s)}(r=c.onBeforeLog)==null||r.call(c),c.logger(t,"info")}}function T(e,t){let n=`[${t}]`;const r=t==="Warning"?"yellow":"red";return n=u.bold(u[r](n)),`${n}${e}`}function b(e){return e.startsWith("[")?e:` ${e}`}function $(e,t=!1){return`${t?le:ue}${e}`}function P(e){const t=e/1e3;if(t<120){const n=N(t);return`${n} second${B(n)}`}{const n=t/60,r=N(n);return`${r} minute${B(r)}`}}function N(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function B(e){return e==="1"?"":"s"}const G=v("utils/executeHook.ts",{userHookErrors:new WeakMap});function de(e){return k(e)?G.userHookErrors.get(e)??!1:!1}function Ne(e,t){const{hookName:n,hookFilePath:r,hookTimeout:{error:i,warning:s}}=t;let o,h;const g=new Promise((l,W)=>{o=p=>{m(),l(p)},h=p=>{m(),W(p)}}),m=()=>{w&&clearTimeout(w),f&&clearTimeout(f)},w=x(s)&&setTimeout(()=>{A(!1,`The ${n}() hook defined by ${r} is slow: it's taking more than ${P(s)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},s),f=x(i)&&setTimeout(()=>{const l=fe(`The ${n}() hook defined by ${r} timed out: it didn't finish after ${P(i)} (https://vike.dev/hooksTimeout)`);h(l)},i);return(async()=>{try{const l=await e();o(l)}catch(l){k(l)&&G.userHookErrors.set(l,{hookName:n,hookFilePath:r}),h(l)}})(),g}function x(e){return!!e&&e!==1/0}function Y(){return typeof window<"u"&&typeof window.scrollY=="number"}const q=v("utils/assertRouterType.ts",{});function pe(){we(ge()),q.isClientRouting=!0}function ge(){return q.isClientRouting!==!1}function we(e){y(Y(),`${u.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),A(e,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function ye(e){return e instanceof Function||typeof e=="function"}function L(e){return Array.isArray(e)}function me(e){return L(e)&&e.every(t=>typeof t=="string")}function ke(e){return k(e)&&Object.values(e).every(t=>typeof t=="string")}function be(e,t,n="unknown"){if(!k(e))return!1;if(!(t in e))return n==="undefined";if(n==="unknown")return!0;const r=e[t];return n==="array"?L(r):n==="object"?k(r):n==="string[]"?me(r):n==="string{}"?ke(r):n==="function"?ye(r):L(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="undefined"?r===void 0:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function j(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}function H(e,t,n){return typeof e=="string"?V(e.split(""),t,n).join(""):V(e,t,n)}function V(e,t,n){const r=[];let i=t>=0?t:e.length+t;a(i>=0&&i<=e.length);let s=n>=0?n:e.length+n;for(a(s>=0&&s<=e.length);!(i===s||(i===e.length&&(i=0),i===s));){const o=e[i];a(o!==void 0),r.push(o),i++}return r}const K=["http://","https://","tauri://","file://"];function Q(e){return K.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function Be(e,t){a(t.includes(" but ")),y(typeof e=="string",`${t} should be a string`),!Q(e)&&(!e.startsWith("/")&&!e.includes(":")?y(!1,`${t} is ${u.cyan(e)} and it should be /${u.cyan(e)} instead (URL pathnames should start with a leading slash)`):y(!1,`${t} isn't a valid URL`))}function xe(e,t){a(Q(e)),a(t.startsWith("/"));const[n,...r]=e.split("#");a(n!==void 0);const i=["",...r].join("#")||null;a(i===null||i.startsWith("#"));const s=i===null?"":E(i.slice(1)),[o,...h]=n.split("?");a(o!==void 0);const g=["",...h].join("?")||null;a(g===null||g.startsWith("?"));const m={},w={};Array.from(new URLSearchParams(g||"")).forEach(([R,C])=>{m[R]=C,w[R]=[...w.hasOwnProperty(R)?w[R]:[],C]});const{origin:f,pathname:l}=We(o,t);a(f===null||f===E(f)),a(l.startsWith("/")),a(f===null||e.startsWith(f));const W=o.slice((f||"").length);Se(e,f,W,g,i);let{pathname:p,hasBaseServer:Z}=ve(l,t);return p=$e(p),a(p.startsWith("/")),{origin:f,pathname:p,pathnameOriginal:W,hasBaseServer:Z,search:m,searchAll:w,searchOriginal:g,hash:s,hashOriginal:i}}function E(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function $e(e){return e=e.replace(/\s+$/,""),e=e.split("/").map(t=>E(t).split("/").join("%2F")).join("/"),e}function We(e,t){var n;a(!e.includes("?")&&!e.includes("#"));{const{origin:r,pathname:i}=z(e);if(r)return{origin:r,pathname:i};a(i===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const r=typeof window<"u"?(n=window==null?void 0:window.document)==null?void 0:n.baseURI:void 0;let i;return r?i=z(r.split("?")[0]).pathname:i=t,{origin:null,pathname:Re(e,i)}}}function z(e){if(K.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),s=[t,n,r].join("/"),o=["",...i].join("/")||"/";return{origin:s,pathname:o}}else return{pathname:e,origin:null}}function Re(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const o in r){const h=r[o];h==""&&o==="0"||h!="."&&(h==".."?n.pop():(i=!1,n.push(h)))}let s=n.join("/");return i&&!s.endsWith("/")&&(s+="/"),s.startsWith("/")||(s="/"+s),s}function je(e){a(e.startsWith("/")),a(!e.includes("?")),a(!e.includes("#"))}function ve(e,t){je(e),a(Te(t));let n=e;if(a(n.startsWith("/")),a(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===H(t,0,-1)&&(r=H(t,0,-1),a(n===r)),n.startsWith(r)?(a(n.startsWith("/")||n.startsWith("http")),a(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),a(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function Te(e){return e.startsWith("/")}function Se(e,t,n,r,i){const s=Le(t,n,r,i);a(e===s)}function Le(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function Ee(e){return/^[a-z0-9][a-z0-9\.\+\-]*:/i.test(e)}function Oe(e,t,n=r=>r){if(a(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),i=e[e.length-1];return r.map(n).join(", ")+` ${t} `+n(i)}function Ue(e,t){const n=t-3;if(a(n>=1),e.length<t)return e;{e=e.substring(0,n);const r=u.dim("...");return e=e+r,e}}Y()&&pe();function He(e,t){const n=[typeof e=="number"?String(e):JSON.stringify(e)];t!==void 0&&n.push(Ue(JSON.stringify(t),30));const r="throw render()",i=`render(${n.join(", ")})`;return _e(e,t,i,r)}function _e(e,t,n,r,i){const s={abortReason:t,_abortCaller:r,_abortCall:n};if(i&&(a(i._isLegacyRenderErrorPage===!0),j(s,i)),typeof e=="string"){const o=e;return Ie(o,r),j(s,{_urlRewrite:o}),F(s)}else{const o=e;return Ae(e,[401,403,404,410,429,500,503],"render"),j(s,{abortStatusCode:o,is404:o===404}),F(s)}}function F(e){const t=new Error("AbortRender");return j(t,{_pageContextAbort:e,[X]:!0}),t}const X="_isAbortError";function Ve(e){return typeof e=="object"&&e!==null&&X in e}function ze(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(a(be(e,"_abortCall","string")),!0):!1}function Fe(e,t,n){if(t)return;const r=n._urlRewrite??n.urlOriginal;a(r);const i=e._pageContextAbort._abortCall;a(i);const s=de(e);let o="";s&&(o=` by ${u.cyan(`${s.hookName}()`)} hook defined at ${s.hookFilePath}`),he(!1,`${u.cyan(i)} thrown${o} while rendering ${u.cyan(r)}`,{onlyOnce:!1})}function Ae(e,t,n){const r=Oe(t.map(i=>i.toString()),"or");A(t.includes(e),`Unepexected status code ${e} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${e} should be added.)`,{onlyOnce:!0})}function Je(e){Ce(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function Ce(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const i=t.indexOf(r);if(i!==-1){const s=[...t.slice(i),r].map(o=>`render('${o}')`).join(" => ");y(!1,`Infinite loop of render() calls: ${s}`)}}t.push(r)})}function De(e,t){const n=[e>0&&u.cyan("throw render('/some-url')"),t>0&&u.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");y(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function Ie(e,t,n){y(e.startsWith("/")||n&&Ee(e),[`Invalid URL ${u.cyan(e)} passed to ${u.cyan(t)}:`,`the URL should start with ${u.cyan("/")}`,n&&`or a valid protocol (${u.cyan("https:")}, ${u.cyan("ipfs:")}, ...)`].filter(Boolean).join(" "))}export{F as A,Ve as B,Fe as C,Pe as D,a,y as b,L as c,k as d,A as e,Y as f,v as g,be as h,ye as i,pe as j,xe as k,Ne as l,ze as m,fe as n,j as o,u as p,Te as q,He as r,H as s,Q as t,M as u,he as v,Oe as w,Be as x,De as y,Je as z};
